
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../chap2/">
      
      
        <link rel="next" href="../chap4/">
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.1.3">
    
    
      
        <title>3 对象的好处和局限性 - 面对对象编程语言：应用和解释</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.c4a75a56.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.a0c5b2b5.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#3" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="面对对象编程语言：应用和解释" class="md-header__button md-logo" aria-label="面对对象编程语言：应用和解释" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            面对对象编程语言：应用和解释
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              3 对象的好处和局限性
            
          </span>
        </div>
      </div>
    </div>
    
    
    
    
      <div class="md-header__source">
        <a href="https://github.com/mrmathematica/ooplai-zh.git" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="面对对象编程语言：应用和解释" class="md-nav__button md-logo" aria-label="面对对象编程语言：应用和解释" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    面对对象编程语言：应用和解释
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/mrmathematica/ooplai-zh.git" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Summary
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap0/" class="md-nav__link">
        前言
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap1/" class="md-nav__link">
        1 从函数到简单对象
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap2/" class="md-nav__link">
        2 寻找 Self
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          3 对象的好处和局限性
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        3 对象的好处和局限性
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#31" class="md-nav__link">
    3.1 抽象数据类型
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    3.2 用子程序表示
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#33" class="md-nav__link">
    3.3 对象
  </a>
  
    <nav class="md-nav" aria-label="3.3 对象">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#331" class="md-nav__link">
    3.3.1 对象的接口
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#332" class="md-nav__link">
    3.3.2 面向对象编程的原则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#333" class="md-nav__link">
    3.3.3 可扩展性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#334-java" class="md-nav__link">
    3.3.4 那 Java 呢？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#34" class="md-nav__link">
    3.4 可扩展性问题
  </a>
  
    <nav class="md-nav" aria-label="3.4 可扩展性问题">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#341-adt" class="md-nav__link">
    3.4.1 ADT
  </a>
  
    <nav class="md-nav" aria-label="3.4.1 ADT">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    扩展：新的操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    扩展：新的数据
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#342-oop" class="md-nav__link">
    3.4.2 OOP
  </a>
  
    <nav class="md-nav" aria-label="3.4.2 OOP">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    扩展：新的数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    扩展：新的操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#35" class="md-nav__link">
    3.5 不同形式的数据抽象
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap4/" class="md-nav__link">
        4 转发和委托
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap5/" class="md-nav__link">
        5 类
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap6/" class="md-nav__link">
        6 继承
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap7/" class="md-nav__link">
        7 充满可能的世界
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#31" class="md-nav__link">
    3.1 抽象数据类型
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    3.2 用子程序表示
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#33" class="md-nav__link">
    3.3 对象
  </a>
  
    <nav class="md-nav" aria-label="3.3 对象">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#331" class="md-nav__link">
    3.3.1 对象的接口
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#332" class="md-nav__link">
    3.3.2 面向对象编程的原则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#333" class="md-nav__link">
    3.3.3 可扩展性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#334-java" class="md-nav__link">
    3.3.4 那 Java 呢？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#34" class="md-nav__link">
    3.4 可扩展性问题
  </a>
  
    <nav class="md-nav" aria-label="3.4 可扩展性问题">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#341-adt" class="md-nav__link">
    3.4.1 ADT
  </a>
  
    <nav class="md-nav" aria-label="3.4.1 ADT">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    扩展：新的操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    扩展：新的数据
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#342-oop" class="md-nav__link">
    3.4.2 OOP
  </a>
  
    <nav class="md-nav" aria-label="3.4.2 OOP">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    扩展：新的数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    扩展：新的操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#35" class="md-nav__link">
    3.5 不同形式的数据抽象
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="3">3 对象的好处和局限性</h1>
<p>在编程语言的课程中，我们这样编程：定义数据类型及其变体，在此之上定义操作这些结构
体的各种“服务”，所谓服务也即对这些数据结构的各种变种分情况进行处理的子程序。这种
编程风格有时被称为“过程式”或“函数设计”的（注意这里的“函数”并不是指“无副作用的”！
）。</p>
<p>在《程序语言：应用和解释》中，我们用<code>define-type</code>来定义数据类型及其变体，
用<code>type-case</code>实现对变种按情况处理的子程序。这种编程方法在其他语言中也很常见：C（
联合体）、Pascal（变体类型）、ML 和 Haskell 的代数数据类型、纯 Scheme 的带标记数
据。</p>
<p>那么，面向对象编程究竟给我们提供了什么呢？它的缺点是什么呢？事实证明，使用面向对
象的语言并不意味着程序就是“面向对象”的。许多 Java 程序就不是，或者至少是牺牲了对
象的某些基本好处的。</p>
<blockquote>
<p>本章基于 William R. Cook 2009 年的《On Understanding Data Abstraction,
Revisited》（再谈对数据抽象的理解）一文。</p>
</blockquote>
<p>本独立章节的目的是，暂时从逐步构建 OOP 的步骤中抽身，转而对比面向对象和过程式编
程，从而明确每种方法各自的优缺点。有趣的是，我们迄今为止构建的简单对象系统完全足
够研究对象的基本好处和局限性了——委托、类、继承等都是有趣的特性，但对于对象来说都
不是<strong>本质</strong>的。</p>
<h2 id="31">3.1 抽象数据类型</h2>
<p>我们先来讨论抽象数据类型（ADT）。ADT 是隐藏其表示、只提供对值的操作的数据类型。</p>
<p>例如，<strong>整数的集合</strong>ADT 可以定义如下：</p>
<pre><code class="language-text">adt Set 是
  empty : Set
  insert : Set x Int -&gt; Set
  isEmpty? : Set -&gt; Bool
  contains? : Set x Int -&gt; Bool
</code></pre>
<p>这种整数集 ADT 有许多可能的表示。例如，可以使用 Scheme 的表来实现它：</p>
<pre><code class="language-Racket">(define empty '())

(define (insert set val)
  (if (not (contains? set val))
      (cons val set)
      set))

(define (isEmpty? set) (null? set))

(define (contains? set val)
  (if (null? set) #f
      (if (eq? (car set) val)
          #t
          (contains? (cdr set) val))))
</code></pre>
<p>客户程序可以使用 ADT 值，而无需知道底层的表示法：</p>
<pre><code class="language-Racket">&gt; (define x empty)
&gt; (define y (insert x 3))
&gt; (define z (insert y 5))
&gt; (contains? z 2)
#f
&gt; (contains? z 5)
#t
</code></pre>
<p>我们也可以用另一种表示方式来实现 ADT 集合，比如使用 PLAI 的 define-type 机制来创
建一个变体类型，将集合编码为链表。</p>
<pre><code class="language-Racket">(define-type Set
  [mtSet]
  [aSet (val number?) (next Set?)])

(define empty (mtSet))

(define (insert set val)
  (if (not (contains? set val))
      (aSet val set)
      set))

(define (isEmpty? set) (equal? set empty))

(define (contains? set val)
  (type-case Set set
    [mtSet () #f]
    [aSet (v next)
          (if (eq? v val)
              #t
              (contains? next val))]))
</code></pre>
<p>前面的示例客户程序运行照旧，即使现在底层表示换掉了：</p>
<pre><code class="language-Racket">&gt; (define x empty)
&gt; (define y (insert x 3))
&gt; (define z (insert y 5))
&gt; (contains? z 2)
#f
&gt; (contains? z 5)
#t
</code></pre>
<h2 id="32">3.2 用子程序表示</h2>
<p>我们也可以把集合看作是由它的<strong>特征函数</strong>定义：该函数读入一个数字，告诉我们这个数
字是否是集合的一部分。在这种情况下，集合就是简单的<code>Int -&gt; Bool</code>函数。（PLAI 一书
中，第十二章中在研究环境的<strong>子程序表示</strong>时有提到。）</p>
<p>空集的特征函数是什么？总是返回假的函数。插入一个新元素所获得的集合呢？</p>
<pre><code class="language-Racket">(define empty (λ (n) #f))

(define (insert set val)
          (λ (n)
            (or (eq? n val)
                (contains? set n))))

(define (contains? set val)
  (set val))
</code></pre>
<p>由于集合由其特征函数表示，<code>contains?</code>只需将该函数应用于该元素。请注意，客户程序
还是完全不受干扰：</p>
<pre><code class="language-Racket">&gt; (define x empty)
&gt; (define y (insert x 3))
&gt; (define z (insert y 5))
&gt; (contains? z 2)
#f
&gt; (contains? z 5)
#t
</code></pre>
<p>集合的子程序表示给我们带了了什么？灵活性！例如，我们可以定义所有偶数的集合：</p>
<pre><code class="language-Racket">(define even
  (λ (n) (even? n)))
</code></pre>
<p>我们前面考虑的任何 ADT 表示，都不能完整地表示这个集合。（为什么？）我们甚至可以
定义非确定的集合：</p>
<pre><code class="language-Racket">(define random
  (λ (n) (&gt; (random) 0.5)))
</code></pre>
<p>使用子程序表示，我们可以更自由地定义集合，此外它们同样可以与已有的集合操作交互！</p>
<pre><code class="language-Racket">&gt; (define a (insert even 3))
&gt; (define b (insert a 5))
&gt; (contains? b 12)
#t
&gt; (contains? b 5)
#t
</code></pre>
<p>相反，在上面我们看到的 ADT 表示中，不同的表示法之间不能互操作。列表实现集合的值
不能被结构体实现的操作使用，反之亦然。ADT 从表示中抽象出来，但一次只允许<strong>一种表
示</strong>。</p>
<h2 id="33">3.3 对象</h2>
<p>从本质上讲，<strong>函数实现的集合就是对象</strong>！请注意对象并<strong>未</strong>抽象出类型：函数实现的
集合的类型非常具体：它是<code>Int -&gt; Bool</code>的函数。当然，正如我们在前面的章节中看到的
，对象是函数的泛化，它可以有多个方法。</p>
<h3 id="331">3.3.1 对象的接口</h3>
<p>我们可以定义<strong>对象接口</strong>（interface）的概念，也就是某个对象所有方法的型签（类型
签名，signature）：</p>
<pre><code class="language-text">interface Set 是
  contains? : Int -&gt; Bool
  isEmpty? : Bool
</code></pre>
<p>使用我们的简单对象系统实现集合对象：</p>
<pre><code class="language-Racket">(define empty
  (OBJECT ()
          ([method contains? (n) #f]
           [method isEmpty? () #t])))

(define (insert s val)
  (OBJECT ()
          ([method contains? (n)
                   (or (eq? val n)
                       (-&gt; s contains? n))]
           [method isEmpty? () #f])))
</code></pre>
<p>请注意，empty 是个对象，insert 是返回对象的工厂函数。集合对象实现了 Set 接口
。<code>empty</code>对象不包含任何值，它的<code>isEmpty？</code>返回<code>#t</code>。<code>insert</code>返回一个新对象，它
的<code>contains?</code>方法类似于前文中集合的特征函数，而<code>isEmpty?</code>返回<code>#f</code>。</p>
<p>客户程序中，构造集合部分不用变，与集合对象交互部分就必须用消息发送了：</p>
<pre><code class="language-Racket">&gt; (define x empty)
&gt; (define y (insert x 3))
&gt; (define z (insert y 5))
&gt; (-&gt; z contains? 2)
#f
&gt; (-&gt; z contains? 5)
#t
</code></pre>
<p>请注意，对象接口本质上就是高阶类型：方法是函数，所以传递对象就是传递函数组。这是
高阶函数式编程的推广。面向对象的程序本质上是高阶的。</p>
<h3 id="332">3.3.2 面向对象编程的原则</h3>
<p><strong>原则：对象只能通过其他对象的公共接口来访问它们</strong></p>
<p>一旦创建了对象，比如上面的 z（所绑定的），对它<strong>唯一</strong>能做的就是通过发送消息进行
交互。不能“打开对象”。对象的任何属性都不可见，可见的只有它的接口。换一种说法：</p>
<p><strong>原则：对象只对自己有详细的了解</strong></p>
<p>这与 ADT 值有本质区别：在<code>type-case</code>的处理中（回忆一下 ADT 实现中
用<code>define-type</code>实现的<code>contains?</code>），我们打开值，从而直接访问其属性。ADT 提供封装
，但为 ADT 的客户提供；不为其实现提供。对象在这方面更进一步。即使是对象的方法，
其实现也不能访问除自身以外对象的属性。</p>
<p>由此我们可以得出另一个基本原则：</p>
<p><strong>原则：对象就是所有对其可能进行的观测的集合，这些观测通过对象接口定义</strong></p>
<p>这是一条强原则，它表明，如果两个对象在对于特定实验（即一组观测）表现相同，那么它
们应该是不可区分的。这意味着使用等值判定操作（如指针相等）违反了 OOP 的这个原则
。使用 Java 中的<code>==</code>，我们可以区分即使是<strong>行为</strong>一致的两个对象。</p>
<h3 id="333">3.3.3 可扩展性</h3>
<p>上述原则可以被认为是 OOP 的本质特征。正如 Cook 所说：“ <em>任何允许区分多个抽象表示
的编程模型都<strong>不是</strong>面向对象的</em> ”。</p>
<p>组件对象模型（COM）是实践中最纯粹的 OO 编程模型之一。COM 遵守上述所有的原则：没
有内置的相等性，没有办法确定某个对象是否是某个类的实例。因此 COM 程序是高度可扩
展的。</p>
<p>请注意，对象的可扩展性实际上完全独立于继承！（我们的语言甚至还没有类。）它来自对
接口的使用。</p>
<h3 id="334-java">3.3.4 那 Java 呢？</h3>
<p>Java 不是一种纯粹的面向对象的语言，并不是因为它有原始类型（primitive type，也有
称作内置类型、基础类型或者基本类型），而是因为它支持的许多操作违反了我们上面描述
的原则。Java 内置支持相等<code>==</code>、<code>instanceof</code>、转换为类类型，这使得两个对象即使行
为一致，也可以被区分。在 Java 中，可以声明一个方法，根据类来接受对象，而不是根据
它们的接口（在 Java 中，类名也是类型）。当然还有就是，Java 允许对象访问其他对象
的内部（公有字段当然可以，但即使私有字段同一类的对象也可以访问！）。</p>
<p>这意味着 Java 也支持 ADT 风格的编程。这没有什么不对的！但重要的是了解这所涉及的
设计上的取舍，然后做出明智的选择。例如，在 JDK 中，某些类在表面上尊重 OO 原则（
允许可扩展性），但其实现使用 ADT 技术（不可扩展，但更高效）。如果你有兴趣，参
见<code>List</code>接口和<code>LinkedList</code>实现。</p>
<p>在 Java 中，“纯 OO”编程基本上就是不使用类名称作为类型（即只在<code>new</code>之后使用类名）
，并且从不使用内置的相等（<code>==</code>）。</p>
<h2 id="34">3.4 可扩展性问题</h2>
<p>面向对象程序设计通常被认为是软件可扩展性方面的灵丹妙药。但是，“可扩展”究竟意味着
什么呢？</p>
<p>可扩展性问题说的是如何定义数据类型（结构＋操作），使之能够支持两种形式的扩展：添
加新的表示变体，或添加新的操作。</p>
<blockquote>
<p>这里，ADT 的意思遵从 Cook 的用法。然而我们需要澄清，这里对扩展性问题的讨论实际
上将对象与变体类型(variant type)（即代数数据类型(algebraic data types)）进行对
比。我们关心的是可扩展的<strong>实现</strong>。这里不关心界面的抽象。</p>
</blockquote>
<p>事实表明，ADT 和对象分别都能很好地支持可扩展性的一个维度，但是在另一维度就不行了
。让我们用一个众所周知的例子来研究此问题：简单表达式的解释器。</p>
<h3 id="341-adt">3.4.1 ADT</h3>
<p>先来考虑 ADT 的做法。表达式的数据类型有三种变体：</p>
<pre><code class="language-Racket">(define-type Expr
   [num  (n number?)]
   [bool (b boolean?)]
   [add (l Expr?) (r Expr?)])
</code></pre>
<p>接下来定义解释器，这是一个函数，用 type-case 处理抽象语法树：</p>
<pre><code class="language-Racket">(define (interp expr)
   (type-case Expr expr
      [num (n) n]
      [bool (b) b]
      [add (l r) (+ (interp l) (interp r))]))
</code></pre>
<p>这是一道很好的 PLAI 练习题。举个例子：</p>
<pre><code class="language-Racket">&gt; (define prog (add (num 1)
                    (add (num 2) (num 3))))
&gt; (interp prog)
6
</code></pre>
<h4 id="_1">扩展：新的操作</h4>
<p>先来考虑给表达式添加一个新操作。除了对表达式进行解释，我们还想做类型检查，也就是
确定它将算得的值的类型（在这里，是<code>number</code>或<code>boolean</code>）。这很简单，但是能检测到
解释过程中出现的失败的情况，比如对两个不是数字的东西进行相加操作：</p>
<pre><code class="language-Racket">(define (typeof expr)
  (type-case Expr expr
    [num (n) 'number]
    [bool (b) 'boolean]
    [add (l r) (if (and (equal? 'number (typeof l))
                        (equal? 'number (typeof r)))
                   'number
                   (error &quot;类型错误：并非数&quot;))]))
</code></pre>
<p>求一下之前那个程序的类型：</p>
<pre><code class="language-Racket">&gt; (typeof prog)
'number
</code></pre>
<p>我们的类型检查器会拒绝不合理的程序：</p>
<pre><code class="language-Racket">&gt; (typeof (add (num 1) (bool #f)))
类型错误：并非数
</code></pre>
<p>反思一下这个扩展案例，我们看到一切都很顺利。想要新的操作，我们只需要定义新的函数
。这种扩展是模块化的，因为只需要在一个地方新加定义。</p>
<h4 id="_2">扩展：新的数据</h4>
<p>接下来考虑另一个维度的可扩展性：添加新的数据变体。假设我们扩展这里的简单语言，增
加新的表达式：<code>ifc</code>。扩展后数据类型的定义是：</p>
<pre><code class="language-Racket">(define-type Expr
  [num  (n number?)]
  [bool (b boolean?)]
  [add (l Expr?) (r Expr?)]
  [ifc (c Expr?) (t Expr?) (f Expr?)])
</code></pre>
<p>修改<code>Expr</code>的定义加上这个新变体破坏了所有现有的函数定义！<code>interp</code>和<code>typeof</code>都不再
成立，因为它们用<code>type-case</code>对表达式“按类型处理”，但是并没有处理<code>ifc</code>的情况。我们
需要修改它们，加上对<code>ifc</code>的处理：</p>
<pre><code class="language-Racket">(define (interp expr)
  (type-case Expr expr
    [num (n) n]
    [bool (b) b]
    [add (l r) (+ (interp l) (interp r))]
    [ifc (c t f)
         (if (interp c)
             (interp t)
             (interp f))]))

(define (typeof expr)
  (type-case Expr expr
    [num (n) 'number]
    [bool (b) 'boolean]
    [add (l r) (if (and (equal? 'number (typeof l))
                        (equal? 'number (typeof r)))
                   'number
                   (error &quot;类型错误：并非数&quot;))]
    [ifc (c t f)
         (if (equal? 'boolean (typeof c))
             (let ((type-t (typeof t))
                   (type-f (typeof f)))
               (if (equal? type-t type-f)
                   type-t
                   (error &quot;类型错误：两个分支的类型不同&quot;)))
             (error &quot;类型错误：并非布尔值&quot;))]))
</code></pre>
<p>程序是正确的：</p>
<pre><code class="language-Racket">&gt; (define prog (ifc (bool false)
                    (add (num 1)
                         (add (num 2) (num 3)))
                    (num 5)))
&gt; (interp prog)
5
</code></pre>
<p>这种情况下的可扩展性就不怎么样了。我们必须修改数据类型的定义，然后修改所有的函数
。</p>
<p>总而言之，使用 ADT，添加新的操作（如<code>typeof</code>）是模块化的所以很容易，但添加新的数
据类型（例如<code>ifc</code>）则不是模块化的所以非常麻烦。</p>
<h3 id="342-oop">3.4.2 OOP</h3>
<p>对象在这些场景下表现如何？</p>
<p>我们从面向对象版本的解释器开始：</p>
<pre><code class="language-Racket">(define (bool b)
  (OBJECT () ([method interp () b])))

(define (num n)
  (OBJECT () ([method interp () n])))

(define (add l r)
  (OBJECT () ([method interp () (+ (-&gt; l interp)
                                   (-&gt; r interp))])))
</code></pre>
<p>请注意，遵循面向对象的设计原则，每个表达式对象都知道如何解释自己。程序中不存在某
个中央解释器能处理所有的表达式。解释程序是通过给该程序发送<code>interp</code>消息来完成：</p>
<pre><code class="language-Racket">&gt; (define prog (add (num 1)
                    (add (num 2) (num 3))))
&gt; (-&gt; prog interp)
6
</code></pre>
<h4 id="_3">扩展：新的数据</h4>
<p>要添加新的数据，比如条件对象 ifc，可以简单地定义新的对象工厂，其中包含该新对象处
理 interp 消息的定义：</p>
<pre><code class="language-Racket">(define (ifc c t f)
  (OBJECT () ([method interp ()
                      (if (-&gt; c interp)
                          (-&gt; t interp)
                          (-&gt; f interp))])))
</code></pre>
<p>现在可以解释包含条件的程序了：</p>
<pre><code class="language-Racket">&gt; (-&gt; (ifc (bool #f)
           (num 1)
           (add (num 1) (num 3))) interp)
4
</code></pre>
<p>这表明，与 ADT 相反，使用 OOP 添加新类型的数据是直接的、模块化的：只需创建新对象
即可。对比 ADT，这是明显的优势。</p>
<h4 id="_4">扩展：新的操作</h4>
<p>但在得出结论，认为 OOP 是软件可扩展性的灵丹妙药之前，我们必须考虑另一种扩展场景
：添加操作。假设我们和以前一样，需要检查程序的类型。这意味着表达式对象现在还需要
理解“typeof”消息。要做到这一点，我们就必须修改所有的对象定义：</p>
<pre><code class="language-Racket">(define (bool b)
  (OBJECT () ([method interp () b]
              [method typeof () 'boolean])))

(define (num n)
  (OBJECT () ([method interp () n]
              [method typeof () 'number])))

(define (add l r)
  (OBJECT () ([method interp () (+ (-&gt; l interp)
                                   (-&gt; r interp))]
              [method typeof ()
                      (if (and (equal? 'number (-&gt; l typeof))
                               (equal? 'number (-&gt; r typeof)))
                          'number
                          (error &quot;类型错误：并非数&quot;))])))

(define (ifc c t f)
  (OBJECT () ([method interp ()
                      (if (-&gt; c interp)
                          (-&gt; t interp)
                          (-&gt; f interp))]
              [method typeof ()
                      (if (equal? 'boolean (-&gt; c typeof))
                          (let ((type-t (-&gt; t typeof))
                                (type-f (-&gt; f typeof)))
                            (if (equal? type-t type-f)
                                type-t
                                (error &quot;类型错误：两个分支的类型不同&quot;)))
                          (error &quot;类型错误：并非布尔值&quot;))])))
</code></pre>
<p>程序是正确的：</p>
<pre><code class="language-Racket">&gt; (-&gt; (ifc (bool #f) (num 1) (num 3)) typeof)
'number
&gt; (-&gt; (ifc (num 1) (bool #f) (num 3)) typeof)
类型错误：并非布尔值
</code></pre>
<p>这个可扩展性场景下，我们被迫修改所有的代码才能添加新方法。</p>
<p>总而言之，对对象来说，添加新的数据类型（例如 ifc）模块化所以容易，但添加新的操作
（例如 typeof）不模块化所以麻烦。</p>
<p>请注意，这就是 ADT 的对偶情况！</p>
<h2 id="35">3.5 不同形式的数据抽象</h2>
<blockquote>
<p>Cook 的论文更深入地讨论了此类数据抽象之间的比较，不可不看！</p>
</blockquote>
<p>ADT 和对象是不同形式的数据抽象，各有优劣。</p>
<p>ADT 的表示类型是私有的，无法篡改或扩展。这对推理（分析）和优化来说是好的。但它（
同时）只允许一种表示。</p>
<p>对象拥有行为接口，因此可以随时定义新的实现。这对灵活性和可扩展性来说是好的。但这
使得分析代码变得困难，并且使某些优化成为不可能。</p>
<p>这两种抽象形式也支持不同形式的模块化扩展。在 ADT 上可以模块化地添加新操作，但是
支持新的数据变体就很麻烦。面向对象的系统可以模块化地添加新的表示法，但添加新的操
作意味着大量的修改。</p>
<p>有一些方法可以绕开此折衷。比如说，在对象的接口中可以公开某些实现细节。这会牺牲一
些可扩展性，但恢复某些优化的可能性。所以，这里根本的问题是设计上的问题：我们究竟
需要什么？</p>
<p>现在你可以明白，为什么许多语言（同时）支持这两种数据抽象。</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.efa0ade1.min.js"></script>
      
        <script src="../js/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>