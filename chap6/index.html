
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../chap5/">
      
      
        <link rel="next" href="../chap7/">
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.1.3">
    
    
      
        <title>6 继承 - 面对对象编程语言：应用和解释</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.c4a75a56.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.a0c5b2b5.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#6" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="面对对象编程语言：应用和解释" class="md-header__button md-logo" aria-label="面对对象编程语言：应用和解释" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            面对对象编程语言：应用和解释
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              6 继承
            
          </span>
        </div>
      </div>
    </div>
    
    
    
    
      <div class="md-header__source">
        <a href="https://github.com/mrmathematica/ooplai-zh.git" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="面对对象编程语言：应用和解释" class="md-nav__button md-logo" aria-label="面对对象编程语言：应用和解释" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    面对对象编程语言：应用和解释
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/mrmathematica/ooplai-zh.git" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Summary
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap0/" class="md-nav__link">
        前言
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap1/" class="md-nav__link">
        1 从函数到简单对象
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap2/" class="md-nav__link">
        2 寻找 Self
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap3/" class="md-nav__link">
        3 对象的好处和局限性
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap4/" class="md-nav__link">
        4 转发和委托
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap5/" class="md-nav__link">
        5 类
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          6 继承
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        6 继承
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#61" class="md-nav__link">
    6.1 类的层次结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#62" class="md-nav__link">
    6.2 方法查找
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#63" class="md-nav__link">
    6.3 字段和继承
  </a>
  
    <nav class="md-nav" aria-label="6.3 字段和继承">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#631" class="md-nav__link">
    6.3.1 继承字段
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#632" class="md-nav__link">
    6.3.2 字段的绑定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#633" class="md-nav__link">
    6.3.3 字段遮蔽
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#64" class="md-nav__link">
    6.4 清理类协议
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#65" class="md-nav__link">
    6.5 发消息给超类
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#66" class="md-nav__link">
    6.6 继承和初始化
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../chap7/" class="md-nav__link">
        7 充满可能的世界
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#61" class="md-nav__link">
    6.1 类的层次结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#62" class="md-nav__link">
    6.2 方法查找
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#63" class="md-nav__link">
    6.3 字段和继承
  </a>
  
    <nav class="md-nav" aria-label="6.3 字段和继承">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#631" class="md-nav__link">
    6.3.1 继承字段
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#632" class="md-nav__link">
    6.3.2 字段的绑定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#633" class="md-nav__link">
    6.3.3 字段遮蔽
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#64" class="md-nav__link">
    6.4 清理类协议
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#65" class="md-nav__link">
    6.5 发消息给超类
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#66" class="md-nav__link">
    6.6 继承和初始化
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="6">6 继承</h1>
<p>既然有了类，我们可能需要一个类似于<a href="../chap4/#42-委托">委托</a>的机制，以便能够重用
和选择性地改善现有的类。因此，我们扩展对象系统，支持<strong>类继承</strong>（class
inheritance）。我们将会看到，有许多问题需要处理。像往常一样，我们将逐步讨论。</p>
<h2 id="61">6.1 类的层次结构</h2>
<p>先来引入一个类<strong>扩展</strong>另一个类的能力（称为它的<strong>超类</strong>(superclass)）。这里只讨
论<strong>单一继承</strong>（single inheritance），一个类只扩展一个类。</p>
<blockquote>
<p>多重继承。C++</p>
</blockquote>
<p>结果就是，类被组织成层次结构。一个类的所有（传递性的）超类被称为其<strong>祖先</strong>；对等
的，一个类的传递<strong>子类</strong>（subclass）集称为它的<strong>后代</strong>。</p>
<p>例如：</p>
<pre><code class="language-Racket">(define Point
  (CLASS extends Root
           ([field x 0])
           ([method x? () (? x)]
            [method x! (new-x) (! x new-x)]
            [method move (n) (-&gt; self x! (+ (-&gt; self x?) n))])))

(define ColorPoint
  (CLASS extends Point
           ([field color 'black])
           ([method color? () (? color)]
            [method color! (clr) (! color clr)])))
</code></pre>
<h2 id="62">6.2 方法查找</h2>
<p>当给对象发送消息时，我们在它的类中查找实现此消息的方法，然后调用之。反映
到<code>CLASS</code>宏的定义中就是：</p>
<pre><code class="language-Racket">[(invoke)
 (if (assoc (second vals) methods)
     (apply ((cdr (assoc (second vals) methods)) (first vals)) (cddr vals))
     (error &quot;message not understood&quot;))]
</code></pre>
<p>有了继承，在对象收到一个在其类中找不到方法的消息时，我们可以在超类中寻找方法，并
依此类推。首先，<code>invoke</code>协议需要修改，将其分成两步：第一步是<code>lookup</code>（查找），包
括当前类中没有找到方法时在超类中进行查找，第二步是实际的<code>invoke</code>步骤。</p>
<pre><code class="language-Racket">(defmac (CLASS extends superclass
               ([field f init] ...)
               ([method m params body] ...))
  #:keywords field method extends
  #:captures self ? !
  (let ([scls superclass]
        (methods
         (local [(defmac (? fd) #:captures self
                   ((obj-class self) 'read self 'fd))
                 (defmac (! fd v) #:captures self
                   ((obj-class self) 'write self 'fd v))]
           (list (cons 'm (λ (self)
                            (λ params body))) ...))))
    (letrec ([class (λ (msg . vals)
                      (case msg
                        ....
                        [(invoke)
                         (let ((method (class 'lookup (second vals))))
                           (apply (method (first vals)) (cddr vals)))]
                        [(lookup)
                         (let ([found (assoc (first vals) methods)])
                           (if found
                               (cdr found)
                               (scls 'lookup (first vals))))]))])
      class)))
</code></pre>
<p><code>CLASS</code>语法抽象扩展了，加了<code>extends</code>子句（这是类定义中新的关键字）。试用这个抽象
之前，我们需要在树的顶部定义一个<strong>根</strong>类，以终结方法查找的过程。如下的<code>Root</code>类就
可以：</p>
<pre><code class="language-Racket">(define Root
  (λ (msg . vals)
    (case msg
      [(lookup) (error &quot;message not understood:&quot; (first vals))]
      [else     (error &quot;root class: should not happen: &quot; msg)])))
</code></pre>
<p><code>Root</code>直接实现为函数而不使用<code>CLASS</code>形式，所以我们无需指定它的超类（它也没有）。
如果收到<code>lookup</code>消息，它会给出消息无法理解的错误。请注意，在此系统中，除
了<code>lookup</code>以外的任何消息发送到根类都是错误。</p>
<p>来看一个非常简单的类继承的例子：</p>
<pre><code class="language-Racket">(define A
  (CLASS extends Root ()
         ([method foo () &quot;foo&quot;]
          [method bar () &quot;bar&quot;])))
(define B
  (CLASS extends A ()
         ([method bar () &quot;B bar&quot;])))

&gt; (define b (new B))
&gt; (-&gt; b foo)
&quot;foo&quot;
&gt; (-&gt; b bar)
&quot;B bar&quot;
</code></pre>
<p>看起来都对了：向<code>B</code>发送其不理解的消息效果正如预期，并且发送<code>bar</code>的结果是<code>B</code>中调
整过而不是<code>A</code>中的方法被执行。换一种说法，方法调用被正确的<strong>延迟绑定</strong>（late
binding）。我们说，<code>B</code>中的<code>bar</code>方法<strong>覆盖</strong>（override）了<code>A</code>中定义的同名方法。</p>
<p>再来看个稍微复杂一点的例子：</p>
<pre><code class="language-Racket">&gt; (define p (new Point))
&gt; (-&gt; p move 10)
&gt; (-&gt; p x?)
10
</code></pre>
<p>来试试<code>ColorPoint</code>：</p>
<pre><code class="language-Racket">&gt; (define cp (new ColorPoint))
&gt; (-&gt; cp color! 'red)
&gt; (-&gt; cp color?)
'red
&gt; (-&gt; cp move 5)
hash-ref: no value found for key
  key: 'x
</code></pre>
<p>发生了什么？看来，我们不能使用<code>ColorPoint</code>的<code>x</code>字段。好吧，我们还没有讨论过在继
承中如何处理字段。</p>
<h2 id="63">6.3 字段和继承</h2>
<p>来看一下我们目前是怎么处理对象创建的：</p>
<pre><code class="language-Racket">[(create)
 (make-obj class
           (make-hash (list (cons 'f init) ...)))]
</code></pre>
<p>问题就在这里：在字典中我们只初始化了当前类声明的字段的值！还需要对祖先类的字段值
进行初始化。</p>
<h3 id="631">6.3.1 继承字段</h3>
<p>对象应该包含其祖先声明的所有字段的值。因此，当创建类时，我们应该确定它的实例的所
有字段。要做到这一点，我们必须扩展类，使其保留所有字段的列表，并能够将该信息提供
给任何需要的子类。</p>
<pre><code class="language-Racket">(defmac (CLASS extends superclass
               ([field f init] ...)
               ([method m params body] ...))
  #:keywords field method extends
  #:captures self ? !
  (let* ([scls superclass]
         [methods ....]
         [fields (append (scls 'all-fields)
                         (list (cons 'f init) ...))])
    (letrec
        ([class (λ (msg . vals)
                  (case msg
                    [(all-fields) fields]
                    [(create) (make-obj class
                                        (make-hash fields))]
                    ....))]))))
</code></pre>
<p>在类的词法环境中，我们引入新的<code>fields</code>标识符。该标识符绑定到类的实例应该有的全部
字段的列表。要获取超类的所有字段，只要向其发送<code>all-fields</code>消息（其实现简单地返回
绑定到<code>fields</code>的表）。创建对象时，我们就要用这些字段来创建新的字典。</p>
<p>因为我们给类的词汇表增加了新消息，所以需要想想如果<code>Root</code>收到这个消息该怎么处理：
它的所有字段是什么？必须是空表，因为我们不加分辨地使用了<code>append</code>：</p>
<pre><code class="language-Racket">(define Root
  (λ (msg . vals)
    (case msg
      [(lookup)     (error &quot;message not understood:&quot; (first vals))]
      [(all-fields) '()]
      [else (error &quot;root class: should not happen: &quot; msg)])))
</code></pre>
<p>来试试这是否有效：</p>
<pre><code class="language-Racket">&gt; (define cp (new ColorPoint))
&gt; (-&gt; cp color! 'red)
&gt; (-&gt; cp color?)
'red
&gt; (-&gt; cp move 5)
&gt; (-&gt; cp x?)
5
</code></pre>
<p>太好了！</p>
<h3 id="632">6.3.2 字段的绑定</h3>
<p>实际上，还有一个问题我们没有考虑过：如果子类定义了一个字段，其名字已经存在于其祖
先之一，会发生什么？</p>
<pre><code class="language-Racket">(define A
 (CLASS extends Root
        ([field x 1]
         [field y 0])
        ([method ax () (? x)])))
(define B
  (CLASS extends A
         ([field x 2])
         ([method bx () (? x)])))

&gt; (define b (new B))
&gt; (-&gt; b ax)
2
&gt; (-&gt; b bx)
2
</code></pre>
<p>在这两种情况下，返回的都是绑定到<code>B</code>的<code>x</code>字段的值。换句话说，和方法一样，字段也是
延迟绑定的。这合理吗？</p>
<blockquote>
<p>强封装</p>
</blockquote>
<p>我们来想一想：对象的目的是将一些（可能可变的）状态封装在适当的程序接口（方法）之
后。显然，对方法延迟绑定是理想的，因为方法是对象的外部接口。那么字段呢？字段应该
是隐藏的、对象的内部状态——换种说法，实现的细节，而不是公开的接口。其实，请注意我
们的语言到目前为止，甚至不能访问另一个对象除<code>self</code>之外的的字段！那么，至少，对字
段的延迟绑定是值得疑问的。</p>
<blockquote>
<p>私有方法应该延时绑定吗？ 他们是延迟绑定的吗？</p>
</blockquote>
<p>来看一下<a href="../chap4/#42-委托">委托</a>是怎么处理字段的？那里，字段只是函数的自由变量
，所以它们遵从<strong>词法作用域</strong>。对字段来说，这是更合理的语义。在类中定义方法时，其
根据该类中直接定义的字段或其超类中的字段。这里的道理是，因为所有这些都是在编写类
定义的时候已知的信息。延迟绑定字段意味着对方法中的所有自由变量重新引入了动态作用
域：有趣的错误之源和头痛的来源！（想想这样的例子，子类意外地引入与超类中已有名称
一样的字段，从而导致混乱。）</p>
<h3 id="633">6.3.3 字段遮蔽</h3>
<p>本节讨论如何定义被称为<strong>字段遮蔽</strong>（field shadowing）的语义：类的字段遮蔽超类的
同名字段，但是方法总是访问它所在的类或其祖先声明的字段。</p>
<p>具体来说，这意味着一个对象可以为同名字段保存不同的值；使用哪一个取决于具体执行的
方法在哪个类定义（这被称为方法的<strong>宿主类</strong>(host class)）。由于这种多重性，只用一
个哈希表是不够了。替代方案，我们在类中保存一份字段名称的列表，并在对象中保存由值
组成的<strong>向量</strong>（vector），通过位置访问向量中的值。字段访问将分两步完成：首先根据
名称列表确定字段的位置，然后访问对象中值向量对应位置的值。</p>
<p>例如，对于上面的类<code>A</code>，名称列表是<code>'(x y)</code>，<code>A</code>一个实例的值向量是<code>#(1 0)</code>。对
于<code>B</code>类，名称列表是<code>'(x y x)</code>，一个实例的值向量是<code>#(1 0 1)</code>。以这种方式保持字段
的优点是，在没有遮蔽的情况下，字段总是在对象内相同的位置中。</p>
<p>要遵从遮蔽的语义，我们（至少）有两个选项。一种方法，我们可以将被遮蔽字段重命，例
如<code>B</code>中的字段名变成<code>'(x0 y x)</code>，这样<code>B</code>中的方法及其后代只能看到<code>x</code>——也就是<code>B</code>中
引入的字段——的最新定义。另一种方法是保持字段名不变，查找从字段列表尾部开始：也就
是说，我们希望在名称列表中找到字段名<strong>最后</strong>的位置。这里我们选择后一种方案。</p>
<p>修改<code>CLASS</code>的定义，以引入向量和字段查找策略：</p>
<pre><code class="language-Racket">....
[(create)
 (let ([values (list-&gt;vector (map cdr fields))])
   (make-obj class values))]
[(read)
 (vector-ref (obj-values (first vals))
             (find-last (second vals) fields))]
[(write)
 (vector-set! (obj-values (first vals))
              (find-last (second vals) fields)
              (third vals))]
....
</code></pre>
<p>创建对象时，我们用初始字段值构造向量。然后，访问字段时，我们用<code>find-last</code>返回的
位置来访问此向量。不过，试一下就知道，此路不通！语义和之前一样，还是错误的。</p>
<p>为什么呢？回忆一下我们是怎么处理字段访问的，即怎么去除<code>?</code>语法糖：</p>
<pre><code class="language-Racket">(defmac (? fd) #:captures self
  ((obj-class self) 'read self 'fd))
</code></pre>
<p>这里写的表达式是，先询问<code>self</code>是哪个类，然后发送給该类<code>read</code>消息。嗯，但
是<code>self</code>是动态绑定到接收方对象的，所以我们总是在要求原来的类访问字段！错误在这里
。不应将<code>read</code>消息发送给接收方的类，而是发送给方法的<strong>宿主类</strong>。怎么实现呢？需要
一种方法，从方法体找到它的宿主类，或者更好的办法，直接访问宿主类的字段列表。</p>
<p>我们可以将字段列表放在方法的词法环境中，就像<code>self</code>那样，但这样的话程序员可能会意
外地影响绑定（与之相反，<code>self</code>一般是面向对象语言中的关键字）。字段列表（以及绑定
它的名称）应该是我们的实现内部的东西。既然我们在类中局部定义了<code>?</code>和<code>!</code>，可以简单
地将字段列表<code>fields</code>限定在这些语法定义的范围内；由宏观的卫生扩展来确保用户代码不
可能意外地影响<code>fields</code>。</p>
<pre><code class="language-Racket">....
(let* ([scls superclass]
       [fields (append (scls 'all-fields)
                       (list (cons 'fd val) ...))]
       [methods
        (local [(defmac (? fd) #:captures self
                  (vector-ref (obj-values self)
                              (find-last 'fd fields)))
                (defmac (! fd v) #:captures self
                  (vector-set! (obj-values self)
                               (find-last 'fd fields)
                               v))]
          ....)]))
</code></pre>
<blockquote>
<p>这个实现并不理想，因为每次字段访问都会调用<code>find-last</code>（昂贵/线性开销）。可以避
免吗？ 如何避免？</p>
</blockquote>
<p>请注意，我们现在直接访问<code>fields</code>表，所以无需再向类发送字段访问消息。对于写入字段
也是一样。</p>
<p>来试试这一切是否能按预期运行：</p>
<pre><code class="language-Racket">(define A
 (CLASS extends Root
        ([field x 1]
         [field y 0])
        ([method ax () (? x)])))
(define B
  (CLASS extends A
         ([field x 2])
         ([method bx () (? x)])))

&gt; (define b (new B))
&gt; (-&gt; b ax)
1
&gt; (-&gt; b bx)
2
</code></pre>
<h2 id="64">6.4 清理类协议</h2>
<p>我们引入<a href="../chap5/">类</a>之后，又对它的协议（protocol）做了不少改变：</p>
<ul>
<li>通过引入<code>lookup</code>将<code>invoke</code>协议分成两部分，<code>lookup</code>专门用于在类的层次结构中查找
  方法定义。</li>
<li>为了能够检索类的字段，添加了<code>all-fields</code>。构建类的时候通过它获取超类的字段列表
  ，追加到当前定义的类的字段列表。</li>
<li>去除了字段访问的<code>read</code>/<code>write</code>协议，以便正确地确定方法中的字段名称的作用域。</li>
</ul>
<p>现在是时候反思一下类协议，看看这里的协议是不是最小化的，还是可以去掉一些部分。判
断的标准是什么？既然我们正在讨论类的协议，它最好确实是依赖于类来处理消息。例如，
之前介绍的<code>read</code>/<code>write</code>协议就可以删除。回忆一下：</p>
<pre><code class="language-Racket">....
[(read)  (dict-ref (obj-values (first vals)) (second vals))]
[(write) (dict-set! (obj-values (first vals)) (second vals)
                    (third vals))]
....
</code></pre>
<p>这里有任何东西依赖于类函数中的自由变量（或者说，依赖于类对象的状态）吗？没有，唯
一需要的输入是当前对象、要访问的字段的名称，以及可能写入的值。因此，我们可以直接
把这些代码放在<code>?</code>和<code>!</code>的展开中，从而有效地“编译掉”一层不必要的解释。</p>
<p>那么<code>invoke</code>呢？ 来看看，它唯一做的是给自己发送一条消息，这个可以直接在扩
展<code>-&gt;</code>时做，这样调用本质上就独立于类了：</p>
<pre><code class="language-Racket">(defmac (-&gt; o m arg ...)
  (let ([obj o])
    ((((obj-class obj) 'lookup 'm) obj) arg ...)))
</code></pre>
<p>类协议的其他部分呢？<code>all-fields</code>、<code>create</code>和<code>lookup</code>都访问了类的内部状态
：<code>all-fields</code>访问了<code>fields</code>；<code>create</code>访问了<code>fields</code>和<code>class</code>本身；<code>lookup</code>访问
了<code>methods</code>和<code>superclass</code>。所以，我们的类只需要了解这三种信息。</p>
<h2 id="65">6.5 发消息给超类</h2>
<p>当某个方法覆盖（override）超类中的方法时，有时候需要能调用超类中的定义。允许这么
做就可以支持许多典型的改进模式，例如在执行方法之前或之后添加要做的事情，比如对其
参数和返回值的进一步处理等等。这被称作<strong>给超类发送</strong>（super send）。我们选
择<code>--&gt;</code>作为给超类发送的语法。</p>
<p>先来看一个例子：</p>
<pre><code class="language-Racket">(define Point
 (CLASS extends Root
          ([field x 0])
          ([method x? () (? x)]
           [method x! (new-x) (! x new-x)]
           [method as-string ()
                   (string-append &quot;Point(&quot;
                                  (number-&gt;string (? x)) &quot;)&quot;)])))

(define ColorPoint
 (CLASS extends Point
          ([field color 'black])
          ([method color? () (? color)]
           [method color! (clr) (! color clr)]
           [method as-string ()
                   (string-append (--&gt; as-string) &quot;-&quot;
                                  (symbol-&gt;string (? color)))])))

&gt; (define cp (new ColorPoint))
&gt; (-&gt; cp as-string)
&quot;Point(0)-black&quot;
</code></pre>
<p>请注意，给超类发送使我们能够在<code>ColorPoint</code>的定义中重用和扩
展<code>Point</code>中<code>as-string</code>的定义。在<code>Java</code>中，这是通过对<code>super</code>调用方法来完成的，但
究竟<code>super</code>是什么？给超类发送的语义是什么？</p>
<p>首先要澄清的是：给超类发送的接收者是啥？在上面的例子中，当使用<code>--&gt;</code>时
，<code>as-string</code>发送给了哪个对象？<code>self</code>！事实上，<code>super</code>只影响了方法查找。一个常见
的误解是，在执行给超类发送时，方法查找从接收方的<strong>超类</strong>开始，而不是从它的类开始
。我们来构造一个小例子，看看为什么这是不正确的：</p>
<pre><code class="language-Racket">(define A
  (CLASS extends Root ()
         ([method m () &quot;A&quot;])))

(define B
  (CLASS extends A ()
         ([method m () (string-append &quot;B&quot; (--&gt; m) &quot;B&quot;)])))

(define C
  (CLASS extends B () ()))

(define c (new C))
(-&gt; c m)
</code></pre>
<p>这个程序返回什么？我们来研究一下。<code>-&gt;</code>展开为发送<code>lookup</code>给<code>c</code>的类，也就是<code>C</code>。
在<code>C</code>中没有<code>m</code>方法，所以转而发送<code>lookup</code>给其超类，<code>B</code>。<code>B</code>找到<code>m</code>对应的方法，并
返回之。下一步调用此方法，第一个参数是当前的<code>self</code>（也就是<code>c</code>），接下来是消息的
参数，在这里为空。对这个方法求值就需要对<code>string-append</code>的三个参数求值，其中第二
个参数是给超类发送。如果使用上述给超类发送的定义，那么<code>m</code>不是在<code>C</code>（接收方的实际
类）中查找，而是在<code>B</code>（它的超类）中查找的。<code>B</code>中有<code>m</code>方法吗？是的，我们正在执行
的就是它……换句话说，如果这么理解<code>super</code>，上述程序将<strong>不会</strong>终止。</p>
<blockquote>
<p>一些动态语言，比如 Ruby，允许在运行时改变类的继承关系。这在基于原型的语言（如
Self 和 JavaScript）中很常见。</p>
</blockquote>
<p>错在哪里？给<code>self</code>发送时，不应该在接收方的超类中查找方法。在这个例子中，我们应该
在<code>A</code>而不是在<code>B</code>中查找<code>m</code>。为此，我们需要知道执行给超类发送的方法的<strong>宿主类的超
类</strong>。这个值应该是在方法体中静态绑定还是动态绑定的？我们刚才已经说过了：它是方法
的宿主类的超类，不可能动态改变（至少在我们的语言中如此）。好在在方法的词法环境中
，已经有了指向超类的绑定，<code>scls</code>。所以，我们只需要引入新的局部宏<code>--&gt;</code>，其展开请
求超类<code>scls</code>来查找消息。<code>--&gt;</code>可以被用户代码使用，所以它要被添加到<code>#:captures</code>标
识符列表中：</p>
<pre><code class="language-Racket">(defmac (CLASS extends superclass
               ([field f init] ...)
               ([method m params body] ...))
  #:keywords field method extends
  #:captures self ? ! --&gt;
  (let* ([scls superclass]
         [fields (append (scls 'all-fields)
                         (list (cons 'f init) ...))]
         [methods
          (local [(defmac (? fd) ....)
                  (defmac (! fd v) ....)
                  (defmac (--&gt; md . args) #:captures self
                    (((scls 'lookup 'md) self) . args))]
            ....)])))
</code></pre>
<p>请注意，<code>lookup</code>现在被发送到当前正在执行的方法的宿主类的超类<code>scls</code>，而不是当前对
象的实际类。</p>
<pre><code class="language-Racket">&gt; (define c (new C))
&gt; (-&gt; c m)
&quot;BAB&quot;
</code></pre>
<h2 id="66">6.6 继承和初始化</h2>
<p>之前已经讨论过，通过引入称为初始器的特殊方法，来<a href="../chap5/#55-初始化">初始化</a>对
象。一旦对象被创建，在被返回给创建者之前，需要调用它的初始器。</p>
<p>现在有了继承，这个过程变复杂了一点，因为如果初始器能相互覆盖，可能会忽略一些必要
的初始化工作。初始器的工作可能非常具体，我们希望避免子类必须处理所有的细节。可以
假定其语义和一般方法的语义一样，那么子类中的<code>initialize</code>可以根据需要调用超类的初
始器。这种自由导致的问题是，在继承的字段还没有一致地初始化时，子类中的初始器就可
能开始处理对象了。为了避免这个问题，在 Java 中，构造函数做的第一件事必须是调用超
类的构造函数（它可以先计算此调用的参数，仅此而已）。即使不在源代码中明确写出，编
译器也会添加这个调用。事实上，在 VM（虚拟机）层面字节码验证器也会检验这一点：因
此，底层的节码操作也无法绕开对超类构造函数的调用。</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.efa0ade1.min.js"></script>
      
        <script src="../js/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>